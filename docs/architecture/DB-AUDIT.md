# CRStats Database Health Audit

> **Generated by:** @data-engineer (Dara) -- Brownfield Discovery Phase 2
> **Date:** 2026-02-27
> **Scope:** Schema design, data integrity, security, performance, storage patterns
> **Schema source:** `shared/schema.ts`
> **Storage layer:** `server/storage.ts`
> **SQL scripts:** `scripts/supabase/rls-and-triggers.sql`, `scripts/supabase/decks-migrations.sql`

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Schema Design Quality](#1-schema-design-quality)
3. [Index Coverage Analysis](#2-index-coverage-analysis)
4. [Data Integrity](#3-data-integrity)
5. [Security -- RLS & Access Control](#4-security----rls--access-control)
6. [Performance Concerns](#5-performance-concerns)
7. [Migration History](#6-migration-history)
8. [Storage Layer Analysis](#7-storage-layer-analysis)
9. [Prioritized Recommendations](#8-prioritized-recommendations)

---

## Executive Summary

The CRStats database is a well-structured PostgreSQL schema with 16 tables served through Supabase with Drizzle ORM. The schema demonstrates good fundamentals -- proper foreign keys, cascade deletes, UUID primary keys, and comprehensive RLS policies. However, several areas require attention:

- **CRITICAL (2):** No `updatedAt` trigger automation; Notification settings duplication creates inconsistency risk.
- **HIGH (4):** Missing indexes on time-based queries; JSONB columns lack containment indexes; `subscriptions` table allows multiple rows per user without a unique constraint; `meta_decks_cache` full-table wipe during refresh risks read failures.
- **MEDIUM (6):** Varchar enums without DB-level constraints; no soft-delete pattern; no `pg_partman` for growing tables; duplicate code in `bootstrapUserData`; no data retention policy enforcement.
- **LOW (4):** Legacy `clash_tag` column; `create-stripe-prices.ts` script uses Replit connector (dead code); naming convention inconsistencies.

**Overall Health Score: 7.0 / 10** -- Solid foundation with actionable gaps.

---

## 1. Schema Design Quality

### 1.1 Normalization

**Rating: GOOD**

The schema follows proper 3NF for most tables. Each entity has a clear single responsibility.

**Issues found:**

| Issue | Severity | Description |
|-------|----------|-------------|
| `user_settings` + `notification_preferences` overlap | HIGH | Both tables store notification toggles. `user_settings` has `notifications_training`, `notifications_billing`, `notifications_system` AND `notification_preferences` has `training`, `billing`, `system`. The code in `routes.ts:isNotificationAllowed()` checks both with a fallback chain. This creates data inconsistency risk. |
| `profiles.clash_tag` + `profiles.default_player_tag` | LOW | Two columns for the same purpose. `buildCanonicalProfileData()` in `storage.ts` syncs them, but the dual-column approach is confusing. `clash_tag` is documented as legacy. |
| `favorite_players.trophies` / `favorite_players.clan` | MEDIUM | Denormalized player data that becomes stale as soon as the player plays a match. No refresh mechanism exists. |

### 1.2 Naming Conventions

**Rating: GOOD (minor inconsistencies)**

| Convention | Status | Notes |
|-----------|--------|-------|
| snake_case table names | PASS | All tables use snake_case |
| snake_case column names | PASS | All columns use snake_case |
| Consistent PK naming | PASS | `id` for generated PKs, `user_id` for natural PKs |
| FK naming convention | PASS | `user_id`, `plan_id`, `push_analysis_id` |
| Index naming | MOSTLY | Mix of `IDX_` prefix (custom) and auto-generated `_unique` suffix (Drizzle implicit) |

**Minor issue:** Index names use uppercase `IDX_`/`UIDX_` prefix while table/column names are lowercase. Not a functional problem but inconsistent with PostgreSQL conventions.

### 1.3 Type Choices

**Rating: GOOD**

| Pattern | Assessment |
|---------|-----------|
| `varchar` for IDs (UUIDs as text) | Acceptable. Supabase Auth uses UUID strings. Minor overhead vs native `uuid` type but avoids cast overhead in RLS policies (`auth.uid()::text`). |
| `varchar` for enums | Works but lacks DB-level validation. See [Data Integrity](#3-data-integrity). |
| `jsonb` for battle data | Correct choice for schemaless API payloads. |
| `real` for `avg_elixir`, `win_rate_estimate` | Appropriate. Single precision is sufficient for these values. |
| `timestamp` without time zone | Drizzle default. Works fine when all timestamps are UTC (which they are via `now()`). |
| `text` vs `varchar` | Mixed usage. `title`/`description`/`content` use `text` (correct), identifiers use `varchar` (correct). |

---

## 2. Index Coverage Analysis

### 2.1 Existing Indexes

16 tables have 15 explicit indexes (see SCHEMA.md). Every `user_id` FK column that participates in per-user queries has an index.

### 2.2 Missing Indexes

| Table | Missing Index | Query That Needs It | Severity |
|-------|--------------|-------------------|----------|
| `coach_messages` | `(user_id, role, created_at)` | `countCoachMessagesToday()` filters by `userId + role='user' + createdAt >= todayStart` | HIGH |
| `push_analyses` | `(user_id, created_at)` | `countPushAnalysesToday()` filters by `userId + createdAt >= todayStart` | HIGH |
| `notifications` | `(user_id, read)` | `markAllNotificationsAsRead()` updates where `userId` and implicitly benefits from `read` filter | MEDIUM |
| `battle_history` | `(user_id, player_tag)` alone | `pruneBattleHistory()` uses `userId + playerTag` without the `battleTime` component. The existing composite index covers this but the column order `(userId, playerTag, battleTime)` is optimal. | OK |
| `subscriptions` | `(stripe_customer_id)` | Not queried directly but would benefit webhook processing that looks up by Stripe customer | LOW |
| `meta_decks_cache` | `(source_range)` | `getMetaDecksLastUpdated({sourceRange})` filters by `source_range` | LOW |

### 2.3 Index Efficiency Assessment

| Index | Assessment |
|-------|-----------|
| `IDX_battle_history_user_tag_time` | Excellent composite for the primary query pattern (user + tag + time range). Covers both fetch and prune operations. |
| `IDX_deck_suggestions_usage_user_type_created` | Perfect match for the daily count query. |
| `UIDX_favorite_players_user_id_player_tag` | Serves both uniqueness and lookup. Well designed. |

---

## 3. Data Integrity

### 3.1 Constraints Analysis

| Aspect | Status | Details |
|--------|--------|---------|
| Primary keys | PASS | All 16 tables have PKs |
| Foreign keys | PASS | All parent-child relationships have FKs with cascade rules |
| Unique constraints | PASS | `users.email`, `subscriptions.stripe_subscription_id`, `battle_history.battle_key`, `meta_decks_cache.deck_hash`, `favorite_players.(user_id, player_tag)` |
| NOT NULL where expected | MOSTLY | Business-critical fields like `user_id`, `title`, `type` are NOT NULL. Some fields that probably should be NOT NULL are nullable (see below). |
| CHECK constraints | MISSING | No CHECK constraints exist anywhere in the schema. |

### 3.2 Missing Constraints

| Table | Column | Issue | Severity |
|-------|--------|-------|----------|
| `subscriptions` | `plan` | No CHECK or ENUM -- can store any string. Should be `CHECK (plan IN ('free', 'pro'))` | MEDIUM |
| `subscriptions` | `status` | No CHECK -- should be `CHECK (status IN ('inactive', 'active', 'canceled', 'past_due'))` | MEDIUM |
| `goals` | `type` | No CHECK -- enforced only by Zod on input | MEDIUM |
| `training_drills` | `status` | No CHECK -- enforced only by Zod on input | MEDIUM |
| `training_plans` | `status` | No CHECK -- enforced only by Zod on input | MEDIUM |
| `profiles` | `role` | No CHECK -- can be set to arbitrary strings | LOW |
| `goals` | `target_value` | No CHECK for `>= 0` -- only Zod validates | LOW |
| `training_drills` | `priority` | No CHECK for `>= 1` -- only code default | LOW |
| `subscriptions` | `user_id` | **Not UNIQUE** -- multiple subscription rows per user are possible. Code selects `ORDER BY created_at DESC LIMIT 1` but nothing prevents orphan rows. | HIGH |

### 3.3 Nullability Concerns

| Column | Current | Should Be | Reason |
|--------|---------|-----------|--------|
| `users.email` | NULLABLE | Depends | Supabase allows anonymous auth without email. If CRStats requires email, make NOT NULL. |
| `profiles.display_name` | NULLABLE | NOT NULL | Bootstrap always sets a display name. Null creates UI edge cases. |
| `battle_history.created_at` | NULLABLE | NOT NULL | Tracking record creation is critical; default exists but can be overridden with NULL. |

### 3.4 Cascade Rules

All user-owned tables use `ON DELETE CASCADE` -- deleting a user cleans up all related data. This is correct for the domain.

The `training_plans.push_analysis_id` uses `ON DELETE SET NULL` -- correct behavior since deleting an analysis should not destroy the plan.

---

## 4. Security -- RLS & Access Control

### 4.1 RLS Configuration

**Rating: EXCELLENT**

RLS is enabled and forced on all 16 tables (`ALTER TABLE ... ENABLE ROW LEVEL SECURITY; FORCE ROW LEVEL SECURITY`).

### 4.2 Policy Summary

| Table | Policy | Type | Logic |
|-------|--------|------|-------|
| `users` | `users_select_own` | SELECT | `id = auth.uid()::text` |
| `users` | `users_update_own` | UPDATE | `id = auth.uid()::text` |
| `profiles` | `profiles_user_own` | ALL | `user_id = auth.uid()::text` |
| `goals` | `goals_user_own` | ALL | `user_id = auth.uid()::text` |
| `favorite_players` | `favorite_players_user_own` | ALL | `user_id = auth.uid()::text` |
| `notifications` | `notifications_user_own` | ALL | `user_id = auth.uid()::text` |
| `user_settings` | `user_settings_user_own` | ALL | `user_id = auth.uid()::text` |
| `notification_preferences` | `notification_preferences_user_own` | ALL | `user_id = auth.uid()::text` |
| `player_sync_state` | `player_sync_state_user_own` | ALL | `user_id = auth.uid()::text` |
| `battle_history` | `battle_history_user_own` | ALL | `user_id = auth.uid()::text` |
| `coach_messages` | `coach_messages_user_own` | ALL | `user_id = auth.uid()::text` |
| `push_analyses` | `push_analyses_user_own` | ALL | `user_id = auth.uid()::text` |
| `training_plans` | `training_plans_user_own` | ALL | `user_id = auth.uid()::text` |
| `training_drills` | `training_drills_user_own` | ALL | Subquery: parent `training_plans.user_id = auth.uid()::text` |
| `subscriptions` | `subscriptions_select_own` | SELECT only | `user_id = auth.uid()::text` |
| `meta_decks_cache` | `meta_decks_cache_select_authenticated` | SELECT | `true` (readable by all authenticated) |
| `deck_suggestions_usage` | `deck_suggestions_usage_user_own` | ALL | `user_id = auth.uid()::text` |

### 4.3 Security Findings

| Finding | Severity | Details |
|---------|----------|---------|
| RLS bypass via `runAsUser` | INFO | When `auth` is not provided, `storage.ts` queries run without RLS context (using the connection pool directly). This is intentional for server-side service operations (webhooks, meta refresh) but creates a two-layer access model. |
| Subscriptions are read-only for users | GOOD | Users can only SELECT their subscription. INSERT/UPDATE is server-side only (Stripe webhooks). |
| `meta_decks_cache` write policy missing for server | INFO | No INSERT/UPDATE policy for `authenticated` role on `meta_decks_cache`. Writes happen through the service pool (bypasses RLS). This is correct since only the server refreshes meta decks. |
| `users` table has no INSERT policy for `authenticated` | GOOD | Users are created by the `handle_new_user` trigger (SECURITY DEFINER function) or by the service-level `upsertUser`. Users cannot create arbitrary user rows. |
| GRANTs are minimal | GOOD | Each table grants only the necessary operations. `subscriptions` gets only SELECT. `deck_suggestions_usage` gets only SELECT + INSERT. |

### 4.4 Auth Flow

1. Supabase Auth issues JWT with `sub` (user UUID)
2. `supabaseAuth.ts` verifies JWT against Supabase JWKS endpoint
3. `getUserStorage(req.auth)` creates a `DatabaseStorage` with auth context
4. `runAsUser()` sets PostgreSQL session variables for RLS:
   - `request.jwt.claims`
   - `request.jwt.claim.sub`
   - `request.jwt.claim.role`
   - `SET LOCAL ROLE authenticated`
5. All queries within the transaction are subject to RLS policies

This is a well-implemented pattern for Supabase + Drizzle.

---

## 5. Performance Concerns

### 5.1 JSONB Usage

| Table | Column | Size Risk | Query Risk |
|-------|--------|-----------|-----------|
| `battle_history` | `battle_json` | **HIGH** -- Each battle is a full Clash Royale API response (~2-5 KB). With 2000 rows per user limit, a single user can have ~5-10 MB of JSONB data. | LOW -- Only `SELECT battle_json` (no JSONB operators in queries). Data is returned as-is. |
| `push_analyses` | `result_json` | MEDIUM -- AI analysis results are moderately large. | LOW -- Only full-row SELECTs. |
| `meta_decks_cache` | `cards` | LOW -- Small `string[]` array (8 card names). Max 50 rows. | LOW |

**Recommendation:** Consider a GIN index on `battle_json` only if future features need to query inside the JSON (e.g., finding battles by game mode). Currently not needed.

### 5.2 N+1 Query Risks

| Location | Pattern | Risk |
|----------|---------|------|
| `bootstrapUserData()` | 4 INSERT + 4 SELECT in one transaction | LOW -- All in single TX, sequential is fine |
| `/api/auth/user` | `getUser` + `bootstrapUserData` + `getProfile` + `getSubscription` + `getUserSettings` | MEDIUM -- 5 queries per auth request. Consider a single SQL with joins. |
| `/api/player/sync` | `getProfile` + API calls + `upsertBattleHistory` + `getBattleHistory` + computations + `getGoals` + goal updates | MEDIUM -- Complex endpoint with many queries, but each is indexed. |
| `metaDecksRefresh` | `mapWithConcurrency(tags, 5, ...)` fetches battles per player then inserts. | LOW -- Bounded concurrency (5), writes are batched. |

### 5.3 Table Growth Concerns

| Table | Growth Rate | Mitigation |
|-------|-------------|-----------|
| `battle_history` | Continuous (every sync) | `pruneBattleHistory()` limits free users to 10 rows, pro to 60 days. Effective but relies on application code, not DB-level policy. |
| `coach_messages` | Per conversation | **No pruning exists.** Messages accumulate indefinitely. |
| `notifications` | Per event | `deleteNotificationsByUser()` exists but is not called automatically. |
| `deck_suggestions_usage` | Per deck request | **No cleanup.** Rows accumulate forever. Only recent rows (today) are queried. |
| `push_analyses` | Per analysis | **No pruning.** Each push analysis creates a row. |

### 5.4 Meta Decks Cache Refresh

The `replaceMetaDecks()` function does a DELETE ALL + INSERT within a transaction. This is simple but:
- During the DELETE-INSERT window, concurrent reads in the same transaction are fine (MVCC)
- However, the `serviceStorage` path (no auth) wraps in a transaction explicitly, which is correct
- Advisory lock (`pg_try_advisory_lock`) prevents concurrent refreshes

**Risk:** LOW after the explicit transaction wrapping was added.

### 5.5 Connection Pool

`db.ts` uses a single `pg.Pool` instance with default settings (10 max connections). For a Supabase-hosted DB with connection limits, this is fine for moderate traffic. High traffic would need PgBouncer or Supabase's pooler.

---

## 6. Migration History

### 6.1 Migration Strategy

The project uses **`drizzle-kit push`** (`npm run db:push`) instead of versioned migrations. This means:
- No `migrations/` folder exists
- Schema changes are pushed directly from `shared/schema.ts` to the database
- No rollback capability
- No migration history tracking

Additionally, two SQL scripts handle Supabase-specific features that Drizzle cannot:

| Script | Purpose | Idempotent? |
|--------|---------|-------------|
| `scripts/supabase/rls-and-triggers.sql` | RLS policies, grants, signup trigger, lightweight schema migrations | YES (`IF EXISTS`, `IF NOT EXISTS`, `DROP POLICY IF EXISTS`) |
| `scripts/supabase/decks-migrations.sql` | `meta_decks_cache` new columns + `deck_suggestions_usage` table creation | YES |

### 6.2 Schema Evolution Evidence

From the SQL scripts, we can infer the following evolution:

1. **Initial schema:** Core tables (`users`, `profiles`, `subscriptions`, `goals`, etc.)
2. **Meta decks expansion:** Added `wins`, `losses`, `draws`, `avg_elixir`, `win_rate_estimate`, `source_region`, `source_range` columns to `meta_decks_cache`
3. **Deck suggestions rate limiting:** Added `deck_suggestions_usage` table
4. **RLS and trigger refinement:** Comprehensive RLS script suggests it was developed iteratively

### 6.3 Apply Script

`scripts/supabase/apply-sql.ts` is a simple script that reads and executes `rls-and-triggers.sql` against the database in a transaction. Run via `npm run supabase:apply`.

---

## 7. Storage Layer Analysis

### 7.1 Architecture

`server/storage.ts` implements the **Repository Pattern** with:
- `IStorage` interface defining all data operations (60+ methods)
- `DatabaseStorage` class implementing the interface
- `serviceStorage` singleton for server-side operations (no RLS)
- `getUserStorage(auth)` factory for per-request user-scoped operations (with RLS)

### 7.2 RLS Context Management (`runAsUser`)

The `runAsUser<T>()` private method wraps every query in an RLS-aware transaction:

```typescript
return db.transaction(async (tx) => {
  await tx.execute(sql`select set_config('request.jwt.claims', ${claimsJson}, true)`);
  await tx.execute(sql`select set_config('request.jwt.claim.sub', ${auth.userId}, true)`);
  await tx.execute(sql`select set_config('request.jwt.claim.role', ${auth.role}, true)`);
  await tx.execute(sql`set local role authenticated`);
  return fn(tx);
});
```

**Assessment:** This is the correct pattern for Supabase RLS with a direct connection pool. Each operation gets its own transaction with proper session variables.

**Concern:** Every single read (including simple SELECTs) opens a transaction with 4 SET commands. This adds overhead. For high-throughput scenarios, consider batching multiple reads into a single `runAsUser` call.

### 7.3 Query Pattern Analysis

| Pattern | Frequency | Assessment |
|---------|-----------|-----------|
| Simple `WHERE user_id = ?` | Very High | All user-scoped queries. Well-indexed. |
| `ORDER BY created_at DESC LIMIT 1` | High | Subscription, plans, analyses. Indexes cover this. |
| `INSERT ... ON CONFLICT DO UPDATE` | High | Upsert pattern for profiles, settings, favorites, sync state. Clean implementation. |
| `INSERT ... ON CONFLICT DO NOTHING` | Medium | Bootstrap idempotency. Correct. |
| `count(*)::int` with date filter | Medium | Daily limits (coach, push, deck suggestions). |
| `DELETE ... WHERE ... NOT IN (subquery)` | Low | `pruneBattleHistory` for free users. Uses `notInArray`. |
| Full table DELETE + INSERT | Low | `replaceMetaDecks`. Wrapped in transaction. |
| `pg_try_advisory_lock` | Low | Meta refresh locking. Proper use. |

### 7.4 Identified Issues in Storage Layer

| Issue | Location | Severity | Description |
|-------|----------|----------|-------------|
| Duplicated bootstrap logic | `bootstrapUserData()` | MEDIUM | The method contains two nearly identical code blocks: one for `!this.auth` (no RLS) and one for `this.auth` (with RLS). ~90 lines duplicated. Should be refactored to share the inner logic. |
| `createSubscription` does upsert-by-query | `createSubscription()` | MEDIUM | Manually queries for existing subscription then either updates or inserts. Should use `ON CONFLICT` on a unique constraint, but `user_id` is not unique (see integrity finding). |
| `any` type in battle methods | `upsertBattleHistory`, `getBattleHistory` | LOW | Battle JSON is typed as `any[]` for both input and output. Loses type safety. |
| Player tag normalization repeated | Multiple methods | LOW | `normalizePlayerTag()` is called redundantly in both `storage.ts` and `routes.ts`. Consider normalizing once at the route level. |
| `countActiveDrills` uses raw SQL fragment | `countActiveDrills()` | LOW | `` sql`${trainingDrills.status} != 'completed'` `` -- could use Drizzle's `ne()` operator for consistency. |

### 7.5 Concurrency Safety

| Operation | Safe? | Details |
|-----------|-------|---------|
| User bootstrap | YES | Uses `ON CONFLICT DO NOTHING` for all inserts |
| Battle upsert | YES | Uses `ON CONFLICT DO NOTHING` on `battle_key` |
| Favorite player upsert | YES | Uses `ON CONFLICT DO UPDATE` on composite unique |
| Meta decks refresh | YES | Advisory lock + transaction |
| Subscription creation | RISKY | Race condition possible if two requests try to create a subscription simultaneously for the same user (no unique constraint on `user_id`) |

---

## 8. Prioritized Recommendations

### CRITICAL

| # | Issue | Recommendation | Effort |
|---|-------|---------------|--------|
| C1 | `user_settings` and `notification_preferences` store overlapping data | **Consolidate notification preferences into one table.** Either remove the `notifications_*` columns from `user_settings` and use `notification_preferences` exclusively, or vice versa. The current dual-fallback logic in `isNotificationAllowed()` is a bug waiting to happen. | Medium |
| C2 | No automatic `updated_at` maintenance | **Add a PostgreSQL trigger** for automatic `updated_at` updates: `CREATE FUNCTION update_updated_at_column() RETURNS trigger ... SET updated_at = now()`. The current code manually sets `updatedAt: new Date()` in every update call, which is error-prone and creates clock skew between app server and DB. | Low |

### HIGH

| # | Issue | Recommendation | Effort |
|---|-------|---------------|--------|
| H1 | Missing indexes on time-filtered count queries | **Add composite indexes:** `CREATE INDEX IDX_coach_messages_user_role_created ON coach_messages(user_id, role, created_at)` and `CREATE INDEX IDX_push_analyses_user_created ON push_analyses(user_id, created_at)`. These are used for daily rate limiting. | Low |
| H2 | `subscriptions.user_id` is not unique | **Add a unique constraint** on `subscriptions.user_id` or implement a proper one-subscription-per-user invariant. Currently multiple rows can exist per user, and the code relies on `ORDER BY created_at DESC LIMIT 1`. This creates orphan rows and race conditions. | Medium |
| H3 | No enum constraints at DB level | **Add CHECK constraints** for at least the critical enum columns: `subscriptions.plan`, `subscriptions.status`, `goals.type`, `training_plans.status`, `training_drills.status`. This prevents data corruption from bugs in future code paths. | Low |
| H4 | `coach_messages` and `deck_suggestions_usage` grow unbounded | **Implement data retention policies.** Options: (1) scheduled job to delete messages older than N days, (2) `pg_cron` cleanup, (3) partition by month. At minimum, add a pruning function similar to `pruneBattleHistory`. | Medium |

### MEDIUM

| # | Issue | Recommendation | Effort |
|---|-------|---------------|--------|
| M1 | `bootstrapUserData` code duplication | **Refactor to extract the shared bootstrap logic** into a private method, calling it from both the auth and no-auth branches. | Low |
| M2 | No database-level migration versioning | **Introduce versioned migrations** (`drizzle-kit generate` + `drizzle-kit migrate`) instead of `drizzle-kit push`. This enables rollbacks, CI verification, and change tracking. Keep the SQL scripts for Supabase-specific features. | Medium |
| M3 | `favorite_players` data staleness | **Add a `last_refreshed_at` column** and refresh the cached `trophies`/`clan` when viewing favorites or during player sync. Currently stale after first save. | Low |
| M4 | `meta_decks_cache` limited to 50 rows | Consider increasing the cap or implementing tiered caching (top 50 by usage, top 50 by win rate, etc.) if users report limited meta deck variety. | Low |
| M5 | N+1 queries in `/api/auth/user` | **Consolidate into a single query** that joins `users`, `profiles`, `subscriptions`, and `user_settings` in one round trip. Current implementation makes 5 separate queries per authentication request. | Medium |
| M6 | Timestamp columns without timezone | **Use `timestamptz`** (TIMESTAMP WITH TIME ZONE) instead of `timestamp`. While current code always uses UTC, explicit timezone awareness prevents subtle bugs if the DB locale changes or if queries use `now()` in different TZ contexts. | Low (schema change) |

### LOW

| # | Issue | Recommendation | Effort |
|---|-------|---------------|--------|
| L1 | `profiles.clash_tag` legacy column | **Plan deprecation:** Rename to `_clash_tag_deprecated`, add a migration to copy any `clash_tag` values to `default_player_tag` if missing, then drop the column. | Low |
| L2 | `create-stripe-prices.ts` uses Replit connector | **Remove or update the Replit-specific script.** The `seed-products.ts` script already provides this functionality using `getUncachableStripeClient()`. The Replit-specific script is dead code. | Trivial |
| L3 | Index naming convention inconsistency | **Standardize to lowercase:** `idx_table_columns` instead of `IDX_table_columns`. Cosmetic but improves DBA experience. | Trivial |
| L4 | `any` types in battle history | **Define a `BattleJson` type** (even if loose) and use it instead of `Record<string, unknown>` / `any`. Helps with IDE support and refactoring safety. | Low |

---

### Recommended Implementation Order

1. **C2** -- Add `updated_at` trigger (quick win, prevents future bugs)
2. **H1** -- Add missing indexes (immediate performance improvement)
3. **H2** -- Add unique constraint on `subscriptions.user_id` (data integrity)
4. **C1** -- Consolidate notification preferences (requires careful migration)
5. **H3** -- Add CHECK constraints (defense in depth)
6. **H4** -- Implement retention policies (prevent unbounded growth)
7. **M1** -- Refactor `bootstrapUserData` (code quality)
8. **M2** -- Introduce versioned migrations (operational maturity)
9. Remaining MEDIUM/LOW items as capacity allows

---

*Audit generated by @data-engineer (Dara) for Brownfield Discovery Phase 2.*
