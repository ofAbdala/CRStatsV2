Voc√™ √© a Replit IA, atuando como **equipe completa de engenharia** (arquitetura, backend, frontend, DevOps, QA e produto) para o SaaS **CRStats (CR Status)**.

‚öôÔ∏è CONTEXTO ATUAL

* O CRStats j√° est√° rodando em produ√ß√£o/teste com:

  * Auth + onboarding + conex√£o de tag Clash Royale.
  * Dashboard com stats reais da API oficial (players/battles).
  * Hist√≥rico de batalhas agrupado em **pushes** (sess√µes de 2+ partidas em at√© 30min).
  * Coach IA b√°sico, com gating PRO.
  * Billing Stripe (modo teste) com webhooks e `subscriptions` atualizando plano PRO.
  * i18n PT-BR / EN-US.
  * Valida√ß√£o com Zod + error boundaries.
* O OpenAI API key (ChatGPT) j√° est√° configurado no ambiente (ex.: `OPENAI_API_KEY`).

  * Use a **API oficial da OpenAI** (Chat Completions).
  * Crie um cliente OpenAI reutiliz√°vel (por exemplo em `lib/openai.ts`).
  * Permita configurar o modelo via env (`OPENAI_MODEL`, default para algo como `gpt-4o-mini` ou similar).

üß™ TESTE REAL (feedback do fundador/jogador)

Usando o app jogando Clash Royale de verdade, os problemas/insights foram:

1. **Atualiza√ß√£o confusa:**

   * Depois de jogar 3/4 partidas e voltar pro app, os dados nem sempre estavam atualizados.
   * √Äs vezes o push atualizava, mas a dashboard geral n√£o.
   * F5 m√∫ltiplos era necess√°rio.
   * A UI falava que os dados foram atualizados, mas nem sempre era verdade.

2. **Coach ainda ‚Äúmockado‚Äù para FREE:**

   * Em streak de derrotas (tilt), nenhum aviso apareceu.
   * O Coach PRO at√© existe, mas o FREE praticamente n√£o sente o coach funcionando.
   * O app ainda n√£o passa a sensa√ß√£o de que **est√° ajudando ativamente** a jogar melhor.

3. **Coach n√£o entende automaticamente a √∫ltima partida:**

   * Exemplo real: perdi pra um deck de X-Besta que, em teoria, meu deck deveria ganhar.
   * Voltei tiltado pro app e queria perguntar:

     * ‚ÄúPor que perdi a √∫ltima partida?‚Äù
   * O ideal: o coach puxa sozinho a √∫ltima partida, decks, stats e j√° explica motivos e melhorias, sem pedir informa√ß√£o extra.

4. **Perfil precisa de leitura de progresso:**

   * O gr√°fico de trof√©us e push est√° √≥timo.
   * Mas falta uma barra clara mostrando **progresso at√© a pr√≥xima arena/liga**.

5. **Centro de Treinamento ainda n√£o est√° integrado ao Coach:**

   * Existe o conceito de Treino, mas n√£o algo que converta a an√°lise do coach em **plano de treino auto-gerado**.
   * O sonho: terminou o push ‚Üí coach analisa ‚Üí o Centro de Treinamento gera drills concretos automaticamente.

üìå OBJETIVO DESTA RODADA

Transformar o CRStats de um **dashboard bonito de stats** num **coach + centro de treinamento que realmente faz o jogador evoluir**, SEM quebrar nada que j√° funciona (auth, billing, PRO, Clash API, pushes, etc.).

Quero um ciclo de jogo assim:

> Jogar ‚Üí clicar ‚ÄúAtualizar dados‚Äù ‚Üí ver push/stats reais ‚Üí Coach analisa √∫ltima partida e √∫ltimo push ‚Üí Centro de Treinamento gera plano de treino ‚Üí Jogar de novo seguindo o treino.

Use **ChatGPT via OpenAI API** como LLM principal, aproveitando a env `OPENAI_API_KEY` j√° configurada.

---

## BLOCO 1 ‚Äî SYNC √öNICO + BOT√ÉO ‚ÄúATUALIZAR DADOS‚Äù

### Problema

* √â preciso dar F5 v√°rias vezes pra todos os stats se alinharem.
* A UI j√° afirmou ‚Äúdados atualizados‚Äù quando eles n√£o estavam.

### O que quero

1. Um **endpoint √∫nico** de sync, ex.: `POST /api/player/sync`:

   * Entrada: user autenticado (pode usar perfil/`clashTag` padr√£o).
   * Comportamento:

     * Puxa dados da API oficial do Clash Royale:

       * Player ‚Üí trof√©us, arena, etc.
       * Battles (√∫ltimas X partidas relevantes).
     * Atualiza o que for persistido no banco (se for o caso).
     * Atualiza `last_synced_at` em `profiles` ou tabela pr√≥pria (ex.: `player_sync_state`).
     * Calcula e devolve em **UM payload**:

       * Perfil (trophies, arena, n√≠vel).
       * Estat√≠sticas agregadas (winrate, streak, tiltLevel preliminar).
       * Lista de batalhas (j√° em ordem correta).
       * Push sessions (usando a l√≥gica atual de gap de 30min, ‚â• 2 partidas).
       * Qualquer dado necess√°rio para dashboard/perfil/coach, pra evitar v√°rios fetch separados.

2. **Componente de UI na dashboard**:

   * Bot√£o ‚ÄúAtualizar dados‚Äù com estado:

     * idle ‚Üí enabled.
     * loading ‚Üí desabilitado + spinner.
   * Ao lado, texto tipo:

     * PT: ‚Äú√öltima atualiza√ß√£o: h√° 5 min‚Äù.
     * EN: ‚ÄúLast updated: 5 min ago‚Äù.
   * Depois do sucesso:

     * Atualizar estado global/contexts (stats, pushes, perfil) com os dados do response.
     * SOMENTE ent√£o mostrar toast/mensagem ‚ÄúDados atualizados‚Äù.

3. Garantir que:

   * Dashboard, Perfil, Coach, Hist√≥rico usam **a mesma fonte de dados** ap√≥s o sync.
   * N√£o h√° diverg√™ncia (ex.: push atualizado, gr√°fico n√£o).

---

## BLOCO 2 ‚Äî COACH FREE LIMITADO + PRO ILIMITADO (ChatGPT)

### Regras de neg√≥cio

* FREE:

  * **5 mensagens/dia** para o coach (pode parametrizar em constante).
* PRO:

  * Mensagens ilimitadas.

### Backend

1. Criar/usar uma tabela para registro de mensagens do coach, se ainda n√£o existir:

   * `coach_messages` ou similar:

     * `id`
     * `user_id`
     * `role` (`"user" | "assistant"`)
     * `content`
     * `created_at`
     * (opcional) `context_type` (`"last_battle" | "general" | "push"`)

2. Fun√ß√£o de dom√≠nio:

   * `countUserCoachMessagesToday(userId): Promise<number>`
   * Usa timezone padr√£o (pode ser UTC) para delimitar o dia.

3. Endpoint de coach (ex.: `POST /api/coach/message`):

   * Antes de chamar o LLM:

     * Se `isPro(userId)` ‚Üí ok, sem limite.
     * Sen√£o:

       * Chamar `countUserCoachMessagesToday`.
       * Se `count >= FREE_DAILY_LIMIT`:

         * Retornar 429 ou 403 com c√≥digo de erro tipo `FREE_COACH_DAILY_LIMIT_REACHED`.

4. Integra√ß√£o com OpenAI:

   * Criar cliente em `lib/openai.ts`:

     * Usar `OPENAI_API_KEY`.
     * Permitir configurar modelo via env `OPENAI_MODEL` (default `gpt-4o-mini` ou similar).
   * Endpoint do coach monta `messages` para ChatCompletions:

     * `system`: instru√ß√µes do coach (j√° existentes + novas sobre tilt/treinos).
     * `user`: pergunta do jogador.
     * `context`: embedar via `system`/`assistant` o contexto do player (√∫ltima batalha/push/metas‚Ä¶).

### Frontend

* Ao receber erro `FREE_COACH_DAILY_LIMIT_REACHED`:

  * Inserir mensagem do tipo:

    * PT: ‚ÄúNo plano FREE voc√™ j√° usou suas 5 perguntas de hoje com o coach. Fa√ßa upgrade para PRO para perguntas ilimitadas.‚Äù
    * EN: ‚ÄúOn FREE plan you‚Äôve already used your 5 coach questions for today. Upgrade to PRO for unlimited coaching.‚Äù
  * Mostrar CTA de upgrade.

---

## BLOCO 3 ‚Äî TILT REAL (E N√ÉO MOCK) + ALERTAS DE TILT

### Objetivo

Se o jogador estiver numa sequ√™ncia bem ruim, o sistema deve:

* Marcar `tiltLevel` real.
* Mostrar isso no push e no coach.
* O coach deve adaptar a resposta, sugerindo pausa/controle.

### L√≥gica sugerida (pode encapsular em fun√ß√£o)

Sobre as **√∫ltimas N partidas** (ex.: 10) e/ou o **√∫ltimo push**:

* `tiltLevel = "high"` se:

  * Existem **3+ derrotas consecutivas**, OU
  * Winrate < 40% e `netTrophies <= -60` nas √∫ltimas X partidas/√∫ltima 1h.

* `tiltLevel = "medium"` se:

  * Winrate entre 40‚Äì50% com `netTrophies < 0`.

* Caso contr√°rio: `none`.

Implementa√ß√£o:

1. Fun√ß√£o de dom√≠nio:

   * `computeTiltLevel(battlesOrPushes): TiltLevel`.

2. UI:

   * No banner do √∫ltimo push (j√° existe):

     * Se `tiltLevel = "high"`:

       * Mostrar um badge/√≠cone adicional:

         * PT: ‚ÄúAlerta de tilt‚Äù.
         * EN: ‚ÄúTilt warning‚Äù.
   * (Opcional) no hist√≥rico de pushes, pode destacar push com tilt alto.

3. Coach:

   * Quando for montar o prompt do coach (√∫ltima partida / √∫ltimo push):

     * Incluir frase no `system`/context:

       * ‚ÄúO jogador est√° possivelmente em tilt: perdeu X de Y nas √∫ltimas Z partidas, com -N trof√©us em T minutos. Ajude com recomenda√ß√µes de pausa e ajustes mentais, al√©m de aspectos t√©cnicos.‚Äù

---

## BLOCO 4 ‚Äî BARRA DE PROGRESSO AT√â A PR√ìXIMA ARENA / LIGA

### Objetivo

No perfil (aba Perfil/Vis√£o Geral), mostrar uma leitura visual clara de:

* Em que arena/league o jogador est√°.
* Quanto falta em trof√©us para a pr√≥xima.

### Implementa√ß√£o

1. Criar uma estrutura de arenas/ligas (se n√£o existir):

   * Array ordenado com:

     * `name`
     * `minTrophies`
   * Ex.: `ARENAS = [{ name: "Arena 10", min: 4000 }, { name: "Arena 11", min: 4300 }, ...]`.

2. Fun√ß√£o de dom√≠nio:

   * `getLeagueProgress(currentTrophies): { currentLeagueName, nextLeagueName, currentMin, nextMin, progressPercent }`
   * `progressPercent`:

     * `(currentTrophies - currentMin) / (nextMin - currentMin)` clampado entre 0 e 1.

3. UI:

   * Na aba Perfil:

     * Barra horizontal (tipo XP bar) com:

       * PT: ‚ÄúProgresso at√© [pr√≥xima arena]: 4200 / 4600 trof√©us (70%)‚Äù.
       * EN: ‚ÄúProgress to [next league]: 4200 / 4600 trophies (70%)‚Äù.
   * Usar i18n e design-system atual (nada muito chamativo, seguir o visual dos cards).

---

## BLOCO 5 ‚Äî COACH ‚ÄúPOR QUE PERDI A √öLTIMA PARTIDA?‚Äù (Contexto autom√°tico)

### Objetivo

Se o jogador perguntar algo como ‚Äúpor que perdi a √∫ltima partida?‚Äù, o coach deve:

* Automaticamente puxar **a √∫ltima batalha real**.
* Ler decks, resultado, trof√©us, contexto de push/tilt.
* Explicar o que provavelmente aconteceu, **sem perguntar deck/infos b√°sicas**.

### Backend

1. `lastBattleContext`:

   * No servi√ßo do coach, criar uma fun√ß√£o:

     * `getLastBattleContext(userId)` ‚Üí

       * Usa `favorite_players` / jogador padr√£o para pegar `playerTag`.
       * Usa dados j√° sincronizados (ou chama Clash API se necess√°rio) para obter a √∫ltima battle.
     * Retorna:

       * Deck do player (ids/cartas).
       * Deck do oponente.
       * Modo (ladder etc.).
       * Resultado, coroas, trof√©us ganhos/perdidos.
       * Parte do push (ex.: sua posi√ß√£o no push, netTrophies do push, tiltLevel).

2. Detectar pergunta de ‚Äú√∫ltima partida‚Äù:

   * Na rota `POST /api/coach/message`, antes do call ao LLM:

     * Normalizar o texto do usu√°rio (lowercase, sem acento).
     * Se contiver padr√µes do tipo:

       * "por que perdi a ultima partida"
       * "por que perdi a ultima"
       * "why did i lose my last game"
       * "why did i lose the last game"
     * Marcar `focus = "last_battle"` e injetar `lastBattleContext` no prompt.

3. Prompt para LLM (ChatGPT):

   * Se `focus = "last_battle"`:

     * `system`:

       * Explicar que ele √© um coach de Clash Royale.
       * Especificar que o contexto da **√∫ltima partida** est√° logo abaixo.
       * Pedir para:

         * Apontar motivos plaus√≠veis da derrota (macro, ciclo, matchup, elixir, decis√µes).
         * Sugerir 2‚Äì3 a√ß√µes pr√°ticas para corrigir isso nos pr√≥ximos jogos.
         * N√£o pedir ao usu√°rio quais decks foram usados ‚Äì j√° est√£o no contexto.
     * `assistant`/`system` extra com JSON/descri√ß√£o do `lastBattleContext`.

---

## BLOCO 6 ‚Äî COACH DE PUSH (AN√ÅLISE AUTOM√ÅTICA DA SESS√ÉO)

### Objetivo

Depois de um push (sess√£o de 2+ partidas), o coach deve:

* Analisar **o push inteiro**, n√£o s√≥ uma partida.
* Gerar:

  * `summary`
  * `strengths[]`
  * `mistakes[]`
  * `recommendations[]`
* Alimentar tanto a UI (card de an√°lise) quanto o Centro de Treinamento.

### Backend

1. `PushAnalysisContext`:

   * Tipo contendo:

     * Perfil do player (trophies, arena).
     * `PushSession` (battles, wins, losses, netTrophies, duration).
     * `tiltLevel` do push.
     * Goals relevantes.

2. Endpoint:

   * `POST /api/coach/push-analysis`:

     * Usa user autenticado.
     * Acha o √∫ltimo `PushSession` (mais recente).
     * Se n√£o houver push com ‚â• 2 partidas ‚Üí retorna erro amig√°vel.
     * Gera `PushAnalysisContext`.
     * Chama LLM (ChatGPT) com prompt espec√≠fico para an√°lise de push.
     * Retorna:

       ```ts
       interface PushAnalysisResult {
         summary: string;
         strengths: string[];
         mistakes: string[];
         recommendations: string[];
       }
       ```

3. Armazenamento:

   * Opcionalmente criar tabela `push_analyses` ligada ao push:

     * `id`, `user_id`, `push_start_time`, `push_end_time`, `result_json`, `created_at`.

### UI

1. Dashboard/Perfil:

   * Na √°rea de push:

     * Card ‚ÄúAn√°lise do √∫ltimo push‚Äù contendo:

       * `summary` resumido.
       * 2‚Äì3 bullets de strengths e mistakes.
       * Lista curta de recomenda√ß√µes.
     * Estado vazio:

       * ‚ÄúJogue um push e clique em Atualizar dados para ver a an√°lise do coach.‚Äù

2. Coach:

   * Quando `PushAnalysisResult` for gerado (ap√≥s sync):

     * Inserir mensagem autom√°tica do coach no chat:

       * PT: ‚ÄúAcabei de analisar seu √∫ltimo push de X partidas. Eis o que eu vi‚Ä¶‚Äù + resumo + recomenda√ß√µes.
       * EN: ‚ÄúI‚Äôve just analyzed your last push of X games. Here‚Äôs what I saw‚Ä¶‚Äù

3. Perguntas do tipo ‚ÄúComo foi meu √∫ltimo push?‚Äù:

   * Detectar frases equivalentes.
   * Reusar/gerar `PushAnalysisResult` e responder com base nisso, n√£o em gen√©rico.

---

## BLOCO 7 ‚Äî CENTRO DE TREINAMENTO INTEGRADO AO COACH

### Objetivo

Converter a an√°lise do push em **plano de treino concreto** automaticamente.

### Backend

1. Tabelas

* `training_plans`:

  * `id`
  * `user_id`
  * `title`
  * `source` (`"push_analysis"` | `"manual"`)
  * `status` (`"active" | "completed" | "archived"`)
  * `created_at`, `updated_at`

* `training_drills`:

  * `id`
  * `plan_id`
  * `focus_area` (`"tilt" | "macro" | "deck" | "matchup" | "fundamentals"`‚Ä¶)
  * `description`
  * `target_games`
  * `completed_games`
  * `mode`
  * `priority`
  * `status` (`"pending" | "in_progress" | "completed"`)
  * `created_from_push_id` (opcional)
  * timestamps

2. Gera√ß√£o de plano

* Fun√ß√£o:

  * `createTrainingPlanFromPushAnalysis(userId, pushAnalysis, pushSession)`:

    * Cria (ou atualiza) um `training_plan` com `source = "push_analysis"` como ‚ÄúPlano atual‚Äù.
    * Para cada `recommendation` da an√°lise:

      * Inferir `focus_area` (ex.: se falar de controle de elixir, √© `"macro"`, se falar de X-Besta, √© `"matchup"`).
      * Criar `training_drill` com:

        * `description` textual.
        * `target_games` (ex.: 3 ou 5 partidas).
        * `mode` default (ladder, por enquanto).
        * `priority` (1‚Äì3, se fizer sentido).

3. Endpoints

* `GET /api/training/plans`

  * Retorna plano atual + drills.
* `POST /api/training/generate-from-last-push`

  * For√ßa gera√ß√£o manual (caso usu√°rio clique).
* `PATCH /api/training/drills/[id]`

  * Atualiza `status` e `completed_games`.

4. Limites FREE x PRO

* FREE:

  * 1 `training_plan` ativo de `source="push_analysis"`.
  * At√© 3 `training_drills` ativos.
  * 1 an√°lise de push/dia.
* PRO:

  * An√°lise de todos os pushes, m√∫ltiplos planos, v√°rios drills, hist√≥rico.

O backend deve aplicar esses limites e retornar erros amig√°veis (ex.: `FREE_TRAINING_LIMIT_REACHED`).

### Frontend

1. Aba Treino / Centro de Treinamento

* Se houver plano ativo:

  * Mostrar card ‚ÄúPlano atual gerado pelo coach‚Äù:

    * Lista de drills com:

      * T√≠tulo (pode ser a primeira frase da descri√ß√£o).
      * Texto explicativo curto.
      * Barra de progresso (`completed_games / target_games`).
      * Bot√£o/checkbox ‚ÄúMarcar como conclu√≠do‚Äù (chama PATCH).
* Se n√£o houver:

  * Estado vazio:

    * PT: ‚ÄúJogue um push e clique em Atualizar dados para gerar um plano de treino com a ajuda do coach.‚Äù
    * EN: ‚ÄúPlay a push and click Refresh data to generate a training plan with your coach.‚Äù

2. Coach x Treino

* Ao mandar a mensagem de an√°lise do √∫ltimo push no Coach:

  * No fim, incluir algo como:

    * PT: ‚ÄúCriei um plano de treino com X exerc√≠cios baseado nisso. Voc√™ pode seguir no Centro de Treinamento.‚Äù
    * EN: ‚ÄúI‚Äôve created a training plan with X drills based on this. You can follow it in the Training Center.‚Äù
  * Se poss√≠vel, incluir bot√£o/link ‚ÄúVer treino‚Äù ‚Üí `/training`.

* Quando o usu√°rio perguntar:

  * ‚ÄúO que devo treinar agora?‚Äù / ‚ÄúWhat should I train now?‚Äù:

    * Se existir plano ativo:

      * Coach responde com base nos drills atuais.
    * Se n√£o existir:

      * Coach sugere jogar um push + clicar em Atualizar dados para gerar o plano.

---

## BLOCO 8 ‚Äî i18n PARA TUDO NOVO + QA

1. **i18n**

   * Todas as novas strings (bot√£o ‚ÄúAtualizar dados‚Äù, ‚Äú√öltima atualiza√ß√£o h√° X min‚Äù, mensagens de limite FREE, tilt warning, progresso de arena, an√°lise de push, Centro de Treinamento) devem ir pros arquivos de tradu√ß√£o PT-BR / EN-US.
   * N√£o deixar texto hardcoded nas p√°ginas novas.

2. **QA ‚Äì Cen√°rios m√≠nimos**

   * Usu√°rio novo FREE em PT-BR:

     * Faz onboarding, joga push, clica em Atualizar dados:

       * Push aparece certo.
       * Tilt √© calculado corretamente em caso de sequ√™ncia ruim.
       * Card de an√°lise de push √© gerado.
       * Centro de Treinamento mostra plano com drills.
       * Coach responde ‚ÄúPor que perdi a √∫ltima partida?‚Äù com base na √∫ltima battle real.
       * Ap√≥s 5 perguntas, limite FREE entra com mensagem de upsell.
   * Usu√°rio PRO:

     * Sem limite de perguntas.
     * Consegue gerar an√°lises de v√°rios pushes e m√∫ltiplos planos de treino (dentro das regras que voc√™ implementar).

üß™ **IMPORTANTE:**

* N√£o quebre nada que j√° funciona (auth, billing, PRO gating, pushes, hist√≥rico, i18n, valida√ß√£o).
* Use o cliente OpenAI de forma robusta:

  * Timeout, tratamento de erro (fallback pra rule-based se LLM falhar).
  * Logs b√°sicos (sem expor secrets).
* Mantenha TypeScript estrito passando e build sem erros.

Implemente todas essas mudan√ßas e, se poss√≠vel, descreva rapidamente ao final:

* Quais arquivos principais foram tocados.
* Como chamar o fluxo de sync/coach/treino em dev para testar.
